import{s as E,a as b,c as k,i as v,d,y as G,e as I}from"../chunks/scheduler.9h8Gne0h.js";import{S as F,i as R,b as c,d as p,m as g,a as l,t as u,e as _,g as j,c as q}from"../chunks/index.lZ1VfIVx.js";import{T as N,a as S,u as V,b as H,E as J,M as K,C as Q}from"../chunks/index.QqwobRxS.js";import{e as L,u as W,o as X}from"../chunks/each.gFMxsgsn.js";import{I as Y,O as Z,a as ee}from"../chunks/Instance.9A-zklLv.js";function O(i,t,n){const e=i.slice();return e[7]=t[n],e[9]=n,e}function te(i){let t,n;return t=new Z({props:{autoRotate:!0,enableDamping:!0}}),{c(){c(t.$$.fragment)},l(e){p(t.$$.fragment,e)},m(e,$){g(t,e,$),n=!0},p:G,i(e){n||(l(t.$$.fragment,e),n=!0)},o(e){u(t.$$.fragment,e),n=!1},d(e){_(t,e)}}}function re(i){let t,n,e,$;return t=new S.PlaneGeometry({props:{args:[30,30]}}),e=new S.MeshStandardMaterial({}),{c(){c(t.$$.fragment),n=b(),c(e.$$.fragment)},l(r){p(t.$$.fragment,r),n=k(r),p(e.$$.fragment,r)},m(r,m){g(t,r,m),v(r,n,m),g(e,r,m),$=!0},p:G,i(r){$||(l(t.$$.fragment,r),l(e.$$.fragment,r),$=!0)},o(r){u(t.$$.fragment,r),u(e.$$.fragment,r),$=!1},d(r){r&&d(n),_(t,r),_(e,r)}}}function ae(i){let t,n,e;return t=new ee({}),{c(){c(t.$$.fragment),n=b()},l($){p(t.$$.fragment,$),n=k($)},m($,r){g(t,$,r),v($,n,r),e=!0},i($){e||(l(t.$$.fragment,$),e=!0)},o($){u(t.$$.fragment,$),e=!1},d($){$&&d(n),_(t,$)}}}function B(i,t){let n,e,$;return e=new S.Group({props:{position:[t[0](),t[0](!1),t[0]()],rotation:[t[1](),t[1](),t[1]()],$$slots:{default:[ae]},$$scope:{ctx:t}}}),{key:i,first:null,c(){n=I(),c(e.$$.fragment),this.h()},l(r){n=I(),p(e.$$.fragment,r),this.h()},h(){this.first=n},m(r,m){v(r,n,m),g(e,r,m),$=!0},p(r,m){t=r;const h={};m&1024&&(h.$$scope={dirty:m,ctx:t}),e.$set(h)},i(r){$||(l(e.$$.fragment,r),$=!0)},o(r){u(e.$$.fragment,r),$=!1},d(r){r&&d(n),_(e,r)}}}function ne(i){let t,n,e,$,r=[],m=new Map,h,y;t=new S.MeshPhysicalMaterial({}),e=new S.DodecahedronGeometry({});let M=L({length:30});const C=s=>s[9];for(let s=0;s<M.length;s+=1){let o=O(i,M,s),w=C(o);m.set(w,r[s]=B(w,o))}return{c(){c(t.$$.fragment),n=b(),c(e.$$.fragment),$=b();for(let s=0;s<r.length;s+=1)r[s].c();h=I()},l(s){p(t.$$.fragment,s),n=k(s),p(e.$$.fragment,s),$=k(s);for(let o=0;o<r.length;o+=1)r[o].l(s);h=I()},m(s,o){g(t,s,o),v(s,n,o),g(e,s,o),v(s,$,o);for(let w=0;w<r.length;w+=1)r[w]&&r[w].m(s,o);v(s,h,o),y=!0},p(s,o){o&3&&(M=L({length:30}),j(),r=W(r,o,C,1,s,M,m,h.parentNode,X,B,h,O),q())},i(s){if(!y){l(t.$$.fragment,s),l(e.$$.fragment,s);for(let o=0;o<M.length;o+=1)l(r[o]);y=!0}},o(s){u(t.$$.fragment,s),u(e.$$.fragment,s);for(let o=0;o<r.length;o+=1)u(r[o]);y=!1},d(s){s&&(d(n),d($),d(h)),_(t,s),_(e,s);for(let o=0;o<r.length;o+=1)r[o].d(s)}}}function $e(i){let t,n,e,$;return t=new S.BoxGeometry({props:{args:[2,2,2]}}),e=new S.ShaderMaterial({props:{uniforms:{color1:{value:{x:1,y:1,z:0}},color2:{value:{x:0,y:1,z:1}}},vertexShader:`
      varying vec2 vUv;

      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        vUv = uv;
      }
    `,fragmentShader:`
      varying vec2 vUv;

      uniform vec3 color1;
      uniform vec3 color2;

      void main () {
        gl_FragColor = vec4(mix(color1, color2, vUv.x), 1.0);
      }
    `}}),{c(){c(t.$$.fragment),n=b(),c(e.$$.fragment)},l(r){p(t.$$.fragment,r),n=k(r),p(e.$$.fragment,r)},m(r,m){g(t,r,m),v(r,n,m),g(e,r,m),$=!0},p:G,i(r){$||(l(t.$$.fragment,r),l(e.$$.fragment,r),$=!0)},o(r){u(t.$$.fragment,r),u(e.$$.fragment,r),$=!1},d(r){r&&d(n),_(t,r),_(e,r)}}}function se(i){let t,n,e,$,r,m,h,y,M,C,s,o,w,P,x,D;return t=new N({}),e=new S.OrthographicCamera({props:{makeDefault:!0,position:[10,8,12],zoom:50,near:-500,far:500,$$slots:{default:[te]},$$scope:{ctx:i}}}),e.$on("create",oe),r=new S.AmbientLight({}),h=new S.DirectionalLight({props:{castShadow:!0,position:[5,20,2.5],"shadow.normalBias":-.1,"shadow.camera.near":.4,"shadow.camera.far":50,"shadow.camera.left":-22,"shadow.camera.right":22,"shadow.camera.top":22,"shadow.camera.bottom":-22}}),M=new S.RectAreaLight({props:{color:"0xff0000",intensity:.5,"position.y":1,width:30,height:30}}),s=new S.Mesh({props:{name:"Floor",castShadow:!0,receiveShadow:!0,"rotation.x":-Math.PI/2,$$slots:{default:[re]},$$scope:{ctx:i}}}),w=new Y({props:{name:"Dodecahedrons",castShadow:!0,receiveShadow:!0,$$slots:{default:[ne]},$$scope:{ctx:i}}}),x=new S.Mesh({props:{name:"Shader Mesh",castShadow:!0,receiveShadow:!0,position:[10,1,0],$$slots:{default:[$e]},$$scope:{ctx:i}}}),{c(){c(t.$$.fragment),n=b(),c(e.$$.fragment),$=b(),c(r.$$.fragment),m=b(),c(h.$$.fragment),y=b(),c(M.$$.fragment),C=b(),c(s.$$.fragment),o=b(),c(w.$$.fragment),P=b(),c(x.$$.fragment)},l(a){p(t.$$.fragment,a),n=k(a),p(e.$$.fragment,a),$=k(a),p(r.$$.fragment,a),m=k(a),p(h.$$.fragment,a),y=k(a),p(M.$$.fragment,a),C=k(a),p(s.$$.fragment,a),o=k(a),p(w.$$.fragment,a),P=k(a),p(x.$$.fragment,a)},m(a,f){g(t,a,f),v(a,n,f),g(e,a,f),v(a,$,f),g(r,a,f),v(a,m,f),g(h,a,f),v(a,y,f),g(M,a,f),v(a,C,f),g(s,a,f),v(a,o,f),g(w,a,f),v(a,P,f),g(x,a,f),D=!0},p(a,[f]){const T={};f&1024&&(T.$$scope={dirty:f,ctx:a}),e.$set(T);const U={};f&1024&&(U.$$scope={dirty:f,ctx:a}),s.$set(U);const z={};f&1024&&(z.$$scope={dirty:f,ctx:a}),w.$set(z);const A={};f&1024&&(A.$$scope={dirty:f,ctx:a}),x.$set(A)},i(a){D||(l(t.$$.fragment,a),l(e.$$.fragment,a),l(r.$$.fragment,a),l(h.$$.fragment,a),l(M.$$.fragment,a),l(s.$$.fragment,a),l(w.$$.fragment,a),l(x.$$.fragment,a),D=!0)},o(a){u(t.$$.fragment,a),u(e.$$.fragment,a),u(r.$$.fragment,a),u(h.$$.fragment,a),u(M.$$.fragment,a),u(s.$$.fragment,a),u(w.$$.fragment,a),u(x.$$.fragment,a),D=!1},d(a){a&&(d(n),d($),d(m),d(y),d(C),d(o),d(P)),_(t,a),_(e,a),_(r,a),_(h,a),_(M,a),_(s,a),_(w,a),_(x,a)}}}const oe=({ref:i})=>i.lookAt(0,0,0);function fe(i){const{scene:t,renderer:n,camera:e}=V();return t.background=new H("black"),new J,new K,[(m=!0)=>(Math.random()-(m?.5:0))*20,()=>Math.random()*Math.PI*2]}class me extends F{constructor(t){super(),R(this,t,fe,se,E,{})}}function ie(i){let t,n;return t=new me({}),{c(){c(t.$$.fragment)},l(e){p(t.$$.fragment,e)},m(e,$){g(t,e,$),n=!0},i(e){n||(l(t.$$.fragment,e),n=!0)},o(e){u(t.$$.fragment,e),n=!1},d(e){_(t,e)}}}function le(i){let t,n;return t=new Q({props:{$$slots:{default:[ie]},$$scope:{ctx:i}}}),{c(){c(t.$$.fragment)},l(e){p(t.$$.fragment,e)},m(e,$){g(t,e,$),n=!0},p(e,[$]){const r={};$&1&&(r.$$scope={dirty:$,ctx:e}),t.$set(r)},i(e){n||(l(t.$$.fragment,e),n=!0)},o(e){u(t.$$.fragment,e),n=!1},d(e){_(t,e)}}}class he extends F{constructor(t){super(),R(this,t,null,le,E,{})}}export{he as component};
